---------------------------------------------------------
tapshex/README.md at main · tombaker/tapshex
Builds on dctap-python to convert into ShEx. 
---------------------------------------------------------

Tom: If it is confusing to read this on the Signal channel, I have summarized
the changes needed in:
https://github.com/tombaker/tapshex/blob/main/tests_primer/nishad/README.md I
hope these changes will be easy for someone who knows Jinja templates...! If I
see how value constraint types and value shapes are handled, I will be back in
business.

Tom: If I can get past this obstacle, I should be able to complete support for
ShExC in time for the ShEx meeting in Basel in two weeks...

Nishad (re: README.md): Wow!! Thanks Tom, this is super handy. Really appreciate it.

Nishad: I am still on the road, back from RDFsummit, but have to stop in
between for a couple of meetings.

---------------------------------------------------------
Expressing cardinality - verbose or compact?

Nishad: Would it perhaps be easier to use the regular syntax for cardinality - ie, {1,}?

Nishad: I prefer this, easy to template less logic and much safer. Verbosity is
the issue here, but still the same template can deal with all combinations and
values for cardinality.

Nishad: One tricky way to deal with this, is: If you are already using PyShex
in taptoshex, you can pipe the template output to pyshex and generate ShExC
with pyshex. Thus it can generate much compact and pretty syntax. But I think
verbose Shex is still fine if you don’t want to bloat your implementation with
Pyshex

---------------------------------------------------------
Value shapes

Nishad: For valueShape 

    {%- if statement.valueShape %} @{{statement.valueShape}}{% endif -%}

Tom: Thank you! That is what I thought. But I am struggling with the nested
if-statements needed for the valueConstraintType "picklist".

---------------------------------------------------------
Picklists

Tom: Maybe it is something like: 
#     {%- if state.valueConstraint %}
#         {%- if statement.valueConstraintType == "picklist" %}
#             {%- for vc in statement.valueConstraint -%}
#               {{vc}}
#             {%- endfor -%}
#         {%- endif -%} }

Tom: I have updated
https://github.com/tombaker/tapshex/blob/main/tests_primer/nishad/README.md
with the part that I still do not understand. If I know how to do the
valueConstraintType, it should be easy to figure out the other (simpler) value
constraint types.

---------------------------------------------------------
Picklist - value shapes in picklists? Is that even an issue??

Nishad: Tom, I still don’t understand the nuances of DCTAP on picklist. It is
bit complex if both literals and valueshapes can be in picklist.

Tom: There is only one case I am interested in: the combination of
valueConstraint (with a Python list) as a value) together with
valueConstraintType "picklist".

Tom: Somebody might think it makes sense to have a list as a value for
valueShape - I don't recall if this came up - but it seems like a pretty
strange edge case.

Tom: So the logic should be: "If there is a value for valueConstraint, and
there is a value for valueConstraintType of "picklist", then process the value
of valueConstraint with a for-loop that prints the list items, enclosed in
angle brackets.

Tom: So it should be something like this:

    if statement.valueConstraint:
	if statement.valueConstraintType == "picklist":
	    print("[")
	    for vc in statement.valueConstraint:
		print(vc)
	    print("]")

    ...with the result:

		ex:state [ex:unassigned ex:assigned];

Tom: In other words, value shapes cannot be in the picklist, but they could be
URIs or literals. The only thorny issue I see is how to quote the resulting
literals. For starters, I'd like to assume that the literals can include spaces
but would not include quotes, so this should be possible:

    ['reddish brown', 'greenish yellow', 'bluish green']

But I don't want to get too far into edge cases. First, I'd like to create TAPs
for (most of) the examples in Primer - all of the examples except for those
that cannot be supported by DCTAP without significantly extending the model
(eg, reverse triple constraints, etc). In fact, I do see a problem here...
Perhaps you meant to say "complex if both literals and nonliterals (eg, URIs)
can be in picklist". If so, then yes, I'm seeing the problem more clearly now.

I am going to post a DCTAP issue proposing that the valueConstraint of
valueConstraintType "picklist" be considered, by default, to be a picklist of
strings (which would mean, in this case, that the output would need to be
surrounded by quotes).

I'm thinking it might be necessary to extend dctap in tapshex by adding
"uri_picklist" and "numeric_picklist" as types.

I guess we will need to discuss this in the group...

Nishad: Tom, the valueNodeType defines what kind of picklist it is, And
valueDataType defines what kind of literal is in the picklist. Since DCTAP is
not mandating anything, and no defaults are there in the proposal, it is
impressive in concept but a real pain in implementation. 

Initially based on the learnings from YAMA, my approach was to include  a
valueShapePicklist as like the picklist constrint since there are not defaults.
But seemed like I failed to convince the issue as an implementer.

Tom: Somebody might think it makes sense to have a list as a value for
valueShape - I don't recall if this came up - but it seems like a pretty
strange edge case.

Nishad: YAMA does this way, at least for generating ShEx

Nishad: picklist is meant for literals, unless the valueNodeType is non-literal. 

Nishad: To make failsafe implementation, it should check the valueNodeType
first before inferring the picklist as valueShapes.

Nishad: Not as an edgecase but it is common that the shape identifiers can be
without a prefix if a base is declared.

Tom: Maybe it is something like: 
#  {%- if state.valueConstraint %}
#         {%- if statement.valueConstraintType == "picklist" %}
#             {%- for vc in statement.valueConstraint -%}
#               {{vc}}
#             {%- endfor -%}
#         {%- endif -%} }

Nishad: This should work, you can directly add [ ] in there.
Like this:

---------------------------------------------------------
Picklists - convert mandatory/repeatable in the template??

[{% for vc in statement.valueConstraint %}{{ vc }} {% endfor %}]
I will try it - thank you!

{% if max == None and min == None %}
    {% set cardinality = "*" %}
{% elif max == None and min != None %}
    {% set cardinality = "+" %}
{% elif max != None and min == None %}
    {% set cardinality = "{" ~ max ~ ",}" %}
{% elif max == min %}
    {% set cardinality = "{"~ max ~"}" %}
{% elif max == 1 and min == 0 %}
    {% set cardinality = "?" %}
{% elif max == None and min == 0 %}
    {% set cardinality = "*" %}
{% elif max == None and min != None %}
    {% set cardinality = "{," ~ max ~ "}" %}
{% else %}
    {% set cardinality = "{" ~ min ~ "," ~ max ~ "}" %}
{% endif %}

{{ cardinality }}

Nishad: This is briefly what I do in YAMA, max and min are cardinality so you can
rewrite and tweak it, this will be enough to produce +*? {m,n} in pure Jinja
approach. But your should validate the min max before passing it in.

Nishad: trim line breaks and white spaces as required (using -)

Tom: I wrote two functions to do this before handing over to Jinja templates:
https://github.com/tombaker/tapshex/blob/main/tapshex/utils.py#L4-L25

Nishad: Cool then is gorilla loop will do the rest

Nishad: There are many graceful ways to write this, but I prefer more idiomatic
code for helping the future me.

Tom: Ah, nice. I was assuming everything would simply be converted to {x,x}
style, but that's nice as an option. I worry about details like when to use
dashes - {% endif %}, {% endif -%}, or {%- endif -%}. Does it matter?

Nishad: For this loop it is pretty easy. You can use it everywhere in this loop.

Tom: I mean - does it matter whether one uses dashes before and after the
percent sign (see above)? Or is it irrelevant?

Nishad: Place cardinality in the suitable place and add single space before it
{{ cardinality }}

Nishad: In the about loop you can add '-' every: {% and %}, like  {%- and -%}

Tom: does it matter if I omit them? Does it change the interpretation, or break
anything?

Nishad: It will add unnessary line breaks and blank lines

Tom: ah! So the dashes suppress extra line returns?

Nishad: yes

Tom: thanks!

Nishad: usually the clean way is to write 

{% if max == None and min == None %}{% set cardinality = "*" %}{% elif max == None and min != None %}{% set cardinality = "+" %}{% elif max != None and min == None %}{% set cardinality = "{" ~ max ~ ",}" %}{% elif max == 1 and min == 1 %} {% set cardinality = "{1}" %}{% elif max == 1 and min == 0 %}{% set cardinality = "?" %}{% elif max == None and min == 0 %} {% set cardinality = "*" %} {% else %} {% set cardinality = "{" ~ min ~ "," ~ max ~ "}" %}{% endif %}{{ cardinality }}

Like this. But it is not readable, and it is difficult to debug.

Tom: clean but difficult read - got it!

Nishad: As you know, I cannot deal with long text, so i prefer more readable template, though it looks stupid most of the time.

Tom: I'll try to get back to this tomorrow - am trying to solve another problem right now
I always go for readability.
